export default {
  async fetch(
    request: Request,
    env: { ASSETS: { fetch: (request: Request) => Promise<Response> } }
  ) {
    const url = new URL(request.url);

    // Apply redirect rules generated into `out/_redirects` (Cloudflare Pages format).
    // This makes the assets-only worker behave like a static host that supports redirects.
    const redirect = await getRedirect(url, env);
    if (redirect) return redirect;

    // Serve static assets generated by `next build` when `NEXT_OUTPUT=export`.
    return env.ASSETS.fetch(request);
  }
};

type RedirectRule = { from: string; to: string; status: number };

let cachedRules: RedirectRule[] | null = null;

async function getRedirect(url: URL, env: { ASSETS: { fetch: (request: Request) => Promise<Response> } }) {
  const rules = await getRedirectRules(env);
  if (rules.length === 0) return null;

  const path = url.pathname;
  const candidates: string[] = [path];
  const pushUnique = (p: string) => {
    if (candidates.indexOf(p) === -1) candidates.push(p);
  };

  // Be forgiving about trailing slashes: match both `/foo` and `/foo/`.
  if (path !== '/' && path.endsWith('/')) pushUnique(path.slice(0, -1));
  if (path !== '/' && !path.endsWith('/')) pushUnique(`${path}/`);

  for (const candidate of candidates) {
    const rule = rules.find((r) => r.from === candidate);
    if (!rule) continue;

    const location = rule.to.startsWith('http')
      ? rule.to
      : new URL(rule.to, url).toString();

    return Response.redirect(location, rule.status as 301 | 302 | 303 | 307 | 308);
  }

  return null;
}

async function getRedirectRules(env: { ASSETS: { fetch: (request: Request) => Promise<Response> } }) {
  if (cachedRules) return cachedRules;

  const res = await env.ASSETS.fetch(new Request('http://assets.local/_redirects'));
  if (!res.ok) {
    cachedRules = [];
    return cachedRules;
  }

  const text = await res.text();
  cachedRules = parseRedirectsFile(text);
  return cachedRules;
}

function parseRedirectsFile(text: string): RedirectRule[] {
  const rules: RedirectRule[] = [];

  for (const rawLine of text.split('\n')) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;

    // Format: /from /to 301
    const parts = line.split(/\s+/);
    if (parts.length < 3) continue;

    const from = parts[0];
    const to = parts[1];
    const status = Number(parts[2]);

    if (!from?.startsWith('/')) continue;
    if (!to) continue;
    if (!Number.isFinite(status)) continue;

    rules.push({ from, to, status });
  }

  return rules;
}

